import { Account, AccountFactory } from './accounts';
import { PublicNode } from './node';
import { IAccountIn, IPair, ITransfer, ISigner, IPublicAccount } from './types';
import { Anchor, Association, Burn, CancelLease, CancelSponsorship, Data, Lease, MappedAnchor, MassTransfer, Register, RevokeAssociation, Sponsorship, Statement, Transfer } from './transactions';
import Binary from './Binary';
import { AccountResolver } from './identities';
import { Relay } from './messages';
export default class LTO {
    readonly networkId: string;
    private _nodeAddress?;
    private _node?;
    accountResolver?: AccountResolver;
    relay?: Relay;
    accountFactories: {
        [_: string]: AccountFactory;
    };
    constructor(networkId?: string);
    set nodeAddress(url: string);
    get nodeAddress(): string;
    set node(node: PublicNode);
    get node(): PublicNode;
    private createAccountResolver;
    private static guardAccount;
    /**
     * Create an account.
     */
    account(settings?: IAccountIn): Account;
    /**
     * Check if the address is valid for the current network.
     */
    isValidAddress(address: string): boolean;
    /**
     * Use DID resolver to resolve an address into a public key account.
     */
    resolveAccount(address: string): Promise<Account>;
    /**
     * Transfer LTO from account to recipient.
     * Amount is number of LTO * 10^8.
     */
    transfer(sender: Account, recipient: string | Account, amount: number, attachment?: Uint8Array | string): Promise<Transfer>;
    /**
     * Transfer LTO from one account to up to 100 recipients.
     */
    massTransfer(sender: Account, transfers: ITransfer[], attachment?: Uint8Array | string): Promise<MassTransfer>;
    /**
     * Burn LTO from account. *poof* it's gone.
     * Amount is number of LTO * 10^8.
     */
    burn(sender: Account, amount: number): Promise<Burn>;
    /**
     * Write one or more hashes to the blockchain.
     */
    anchor(sender: Account, ...anchors: Uint8Array[]): Promise<Anchor>;
    anchor(sender: Account, ...anchors: IPair<Uint8Array>[]): Promise<MappedAnchor>;
    /**
     * Register public keys on the blockchain.
     */
    register(sender: Account, ...accounts: Array<IPublicAccount | ISigner>): Promise<Register>;
    /**
     * Issue an association between accounts.
     */
    associate(sender: Account, type: number, recipient: string | Account, subject?: Uint8Array, expires?: Date | number, data?: Record<string, number | boolean | string | Uint8Array>): Promise<Association>;
    /**
     * Revoke an association between accounts.
     */
    revokeAssociation(sender: Account, type: number, recipient: string | Account, subject?: Uint8Array): Promise<RevokeAssociation>;
    /**
     * Make a public statement on the blockchain.
     */
    makeStatement(sender: Account, type: number, recipient?: string | Account, subject?: Uint8Array, data?: Record<string, number | boolean | string | Uint8Array>): Promise<Statement>;
    /**
     * Lease an amount to a public node for staking.
     */
    lease(sender: Account, recipient: string | Account, amount: number): Promise<Lease>;
    /**
     * Cancel a staking lease.
     */
    cancelLease(sender: Account, leaseId: string): Promise<CancelLease>;
    /**
     * Sponsor an account.
     */
    sponsor(sender: Account, recipient: string | Account): Promise<Sponsorship>;
    /**
     * Stop sponsoring an account.
     */
    cancelSponsorship(sender: Account, recipient: string | Account): Promise<CancelSponsorship>;
    /**
     * Get the current account balance.
     */
    getBalance(account: Account | string): Promise<number>;
    /**
     * Set account data.
     */
    setData(account: Account, data: Record<string, number | boolean | string | Uint8Array>): Promise<Data>;
    /**
     * Get account data.
     */
    getData(account: Account | string): Promise<Record<string, number | boolean | string | Binary>>;
}
