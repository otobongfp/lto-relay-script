"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EVENT_CHAIN_V2 = exports.EVENT_CHAIN_V1 = void 0;
const Event_1 = __importDefault(require("./Event"));
const Binary_1 = __importDefault(require("../Binary"));
const MergeConflict_1 = __importDefault(require("./MergeConflict"));
const utils_1 = require("@noble/hashes/utils");
const bytes_1 = require("../utils/bytes");
const base_1 = require("@scure/base");
const sha256_1 = require("@noble/hashes/sha256");
const crypto_1 = require("../utils/crypto");
const convert_1 = require("../utils/convert");
exports.EVENT_CHAIN_V1 = 0x41;
exports.EVENT_CHAIN_V2 = 0x42;
const DERIVED_ID_VERSION = 0x51;
class EventChain {
    constructor(idOrAccount, nonce) {
        this.events = [];
        if (typeof idOrAccount === 'string') {
            this.id = idOrAccount;
            this.networkId = (0, crypto_1.getNetwork)(this.id);
        }
        else {
            const account = idOrAccount;
            const nonceBytes = typeof nonce !== 'undefined' ? EventChain.createNonce(nonce) : EventChain.getRandomNonce();
            this.networkId = (0, crypto_1.getNetwork)(account.address);
            this.id = EventChain.buildId(exports.EVENT_CHAIN_V2, this.networkId, Binary_1.default.fromBase58(account.publicKey), nonceBytes);
        }
    }
    get version() {
        return Binary_1.default.fromBase58(this.id)[0];
    }
    /** @deprecated */
    static create(account, nonce) {
        return new EventChain(account, nonce);
    }
    createDerivedId(nonce) {
        const nonceBytes = nonce ? EventChain.createNonce(nonce) : EventChain.getRandomNonce();
        return EventChain.buildId(DERIVED_ID_VERSION, this.networkId, Binary_1.default.fromBase58(this.id), nonceBytes);
    }
    isDerivedId(id) {
        return EventChain.validateId(DERIVED_ID_VERSION, this.networkId, id, Binary_1.default.fromBase58(this.id));
    }
    add(eventOrChain) {
        if (this.events.length > 0 && !this.latestEvent.isSigned())
            throw new Error('Unable to add event: last event on chain is not signed');
        if (eventOrChain instanceof EventChain) {
            this.addChain(eventOrChain);
        }
        else {
            this.addEvent(eventOrChain);
        }
        return this;
    }
    addEvent(event) {
        if (!event.previous)
            event.previous = this.latestHash;
        event.version = this.version;
        this.assertEvent(event);
        this.events.push(event);
    }
    addChain(chain) {
        if (chain.id !== this.id)
            throw Error('Chain id mismatch');
        let offset = 0;
        if (chain.partial) {
            offset = this.events.findIndex((event) => event.hash.hex === chain.partial.hash.hex) + 1;
            if (offset === 0)
                throw new Error(`Events don't fit onto this chain: Event ${chain.partial.hash.base58} not found`);
        }
        for (const [index, event] of chain.events.entries()) {
            if (!this.events[offset + index]) {
                this.assertEvent(event);
                this.events.push(event);
            }
            else if (this.events[offset + index].hash.hex !== event.hash.hex) {
                throw new MergeConflict_1.default(this, this.events[offset + index], chain.events[index]);
            }
        }
    }
    has(event) {
        const hash = event instanceof Event_1.default ? event.hash : event;
        return !!this.events.find((event) => event.hash.hex === hash.hex);
    }
    get latestHash() {
        return this.events.length == 0 ? this.partial?.hash || this.initialHash : this.events.slice(-1)[0].hash;
    }
    get initialHash() {
        return Binary_1.default.fromBase58(this.id).hash();
    }
    get latestEvent() {
        return this.events[this.events.length - 1];
    }
    get state() {
        if (this.events.length > 0 && !this.events[this.events.length - 1].isSigned()) {
            throw new Error('Unable to get state: last event on chain is not signed');
        }
        return this.stateAt(this.events.length);
    }
    get initialState() {
        return Binary_1.default.fromBase58(this.id).reverse().hash();
    }
    stateAt(length) {
        if (length > this.events.length)
            throw new Error('Unable to get state: out of bounds');
        const initial = this.partial?.state ?? this.initialState;
        return this.events.slice(0, length).reduce((state, event) => Binary_1.default.concat(state, event.hash).hash(), initial);
    }
    assertEvent(event) {
        if (!event.previous || event.previous.hex != this.latestHash.hex)
            throw new Error(`Event doesn't fit onto the chain after ${this.latestHash.base58}`);
        if (!event.verifyHash())
            throw new Error(`Invalid hash of event ${event.hash.base58}`);
        if (event.isSigned() && !event.verifySignature())
            throw new Error(`Invalid signature of event ${event.hash.base58}`);
    }
    validate() {
        if (this.events.length === 0)
            throw new Error('No events on event chain');
        this.validateEvents();
        if (this.events[0].previous.hex === this.initialHash.hex)
            this.validateGenesis();
    }
    validateEvents() {
        let previous = this.partial?.hash ?? this.initialHash;
        for (const event of this.events) {
            if (!event.isSigned()) {
                let desc;
                try {
                    desc = `Event ${event.hash.base58}`;
                }
                catch (e) {
                    desc = event === this.latestEvent ? 'Last event' : `Event after ${previous.base58}`;
                }
                throw new Error(`${desc} is not signed`);
            }
            if (!event.verifyHash())
                throw new Error(`Invalid hash of event ${event.hash.base58}`);
            if (!event.verifySignature())
                throw new Error(`Invalid signature of event ${event.hash.base58}`);
            if (previous.hex !== event.previous.hex)
                throw new Error(`Event ${event.hash.base58} doesn't fit onto the chain`);
            previous = event.hash;
        }
    }
    validateGenesis() {
        const isValid = EventChain.validateId(exports.EVENT_CHAIN_V2, this.networkId, this.id, this.events[0].signKey.publicKey) ||
            EventChain.validateId(exports.EVENT_CHAIN_V1, this.networkId, this.id, this.events[0].signKey.publicKey);
        if (!isValid)
            throw new Error('Genesis event is not signed by chain creator');
    }
    isSigned() {
        return this.events.every((e) => e.isSigned());
    }
    startingWith(start) {
        return this.createPartial(start, 0);
    }
    startingAfter(start) {
        return this.createPartial(start, 1);
    }
    createPartial(start, offset) {
        const startHash = start instanceof Event_1.default ? start.hash : start;
        if (this.initialHash.hex === startHash.hex)
            return this;
        const foundIndex = this.events.findIndex((e) => e.hash.hex === startHash.hex);
        if (foundIndex < 0)
            throw new Error(`Event ${startHash.hex} is not part of this event chain`);
        const index = foundIndex + offset;
        if (index === 0)
            return this;
        const chain = new EventChain(this.id);
        chain.partial = {
            hash: this.events[index - 1].hash,
            state: this.stateAt(index),
        };
        chain.events = this.events.slice(index);
        return chain;
    }
    isPartial() {
        return !!this.partial;
    }
    isCreatedBy(account) {
        const networkId = (0, crypto_1.getNetwork)(account.address);
        const publicKey = Binary_1.default.fromBase58(account.publicKey);
        return (EventChain.validateId(exports.EVENT_CHAIN_V2, networkId, this.id, publicKey) ||
            EventChain.validateId(exports.EVENT_CHAIN_V1, networkId, this.id, publicKey));
    }
    get anchorMap() {
        const map = [];
        let state = this.partial?.state ?? this.initialState;
        for (const event of this.events) {
            map.push({ key: state, value: event.hash, signer: (0, crypto_1.buildAddress)(event.signKey.publicKey, this.networkId) });
            state = Binary_1.default.concat(state, event.hash).hash();
        }
        return map;
    }
    toJSON() {
        const events = this.events.map((event) => event.toJSON());
        if (this.partial)
            events.unshift({ hash: this.partial.hash.base58, state: this.partial.state.base58 });
        return { id: this.id, events };
    }
    static from(data) {
        const chain = new EventChain(data.id);
        const chainVersion = chain.version;
        if (data.events.length === 0)
            return chain;
        if ('state' in data.events[0]) {
            const partial = data.events.shift();
            chain.partial = {
                hash: Binary_1.default.fromBase58(partial.hash),
                state: Binary_1.default.fromBase58(partial.state),
            };
        }
        for (const eventData of (data.events ?? [])) {
            chain.events.push(Event_1.default.from(eventData, chainVersion));
        }
        return chain;
    }
    static createNonce(input) {
        return Uint8Array.from((0, sha256_1.sha256)(input).slice(0, 20));
    }
    static getRandomNonce() {
        return (0, utils_1.randomBytes)(20);
    }
    static buildId(prefix, network, group, randomBytes) {
        if (randomBytes.length !== 20)
            throw new Error('Random bytes should have a length of 20');
        const prefixBytes = Uint8Array.from([prefix]);
        const networkBytes = (0, convert_1.stringToByteArray)(network);
        const publicKeyHashPart = (0, crypto_1.secureHash)(group).slice(0, 20);
        const rawId = (0, utils_1.concatBytes)(prefixBytes, networkBytes, randomBytes, publicKeyHashPart);
        const addressHash = (0, crypto_1.secureHash)(rawId).slice(0, 4);
        return base_1.base58.encode((0, utils_1.concatBytes)(rawId, addressHash));
    }
    static validateId(prefix, network, id, group) {
        const idBytes = base_1.base58.decode(id);
        if (idBytes.length !== 46 || idBytes[0] !== prefix || String.fromCharCode(idBytes[1]) !== network)
            return false;
        const rawId = idBytes.slice(0, 42);
        const check = idBytes.slice(42);
        const addressHash = (0, crypto_1.secureHash)(rawId).slice(0, 4);
        let res = (0, bytes_1.compareBytes)(check, addressHash);
        if (res && group) {
            const keyBytes = rawId.slice(22);
            const publicKeyHashPart = Uint8Array.from((0, crypto_1.secureHash)(group).slice(0, 20));
            res = (0, bytes_1.compareBytes)(keyBytes, publicKeyHashPart);
        }
        return res;
    }
}
exports.default = EventChain;
//# sourceMappingURL=EventChain.js.map