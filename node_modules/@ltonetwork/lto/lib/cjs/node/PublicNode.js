"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const transactions_1 = require("../transactions");
const errors_1 = require("../errors");
class PublicNode {
    constructor(url, apiKey = '') {
        this.url = url.replace(/\/$/, '');
        this.apiKey = apiKey;
    }
    // Can be overridden by mock for testing
    fetch(url, options) {
        return fetch(url, options);
    }
    async post(endpoint, postData, headers = {}) {
        endpoint = endpoint.replace(/^\//, '');
        if (this.apiKey)
            headers['X-API-Key'] = this.apiKey;
        headers['content-type'] = 'application/json';
        const body = typeof postData === 'string' ? postData : JSON.stringify(postData);
        const response = await this.fetch(`${this.url}/${endpoint}`, { method: 'POST', headers, body });
        if (!response.ok)
            throw new errors_1.RequestError(`${this.url}/${endpoint}`, await response.json());
        return await response.json();
    }
    async get(endpoint, headers = {}) {
        endpoint = endpoint.replace(/^\//, '');
        if (this.apiKey)
            headers['X-API-Key'] = this.apiKey;
        const response = await this.fetch(`${this.url}/${endpoint}`, { method: 'GET', headers });
        if (!response.ok)
            throw new errors_1.RequestError(`${this.url}/${endpoint}`, await response.json());
        return await response.json();
    }
    async broadcast(transaction) {
        const data = await this.post('/transactions/broadcast', transaction);
        return (0, transactions_1.txFromData)(data);
    }
    async submit(transaction) {
        const data = await this.post('/transactions/submit', transaction);
        return (0, transactions_1.txFromData)(data);
    }
    status() {
        return this.get('/node/status');
    }
    async version() {
        return (await this.get('/node/version')).version;
    }
}
exports.default = PublicNode;
//# sourceMappingURL=PublicNode.js.map