"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const accounts_1 = require("./accounts");
const node_1 = require("./node");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const transactions_1 = require("./transactions");
const Binary_1 = __importDefault(require("./Binary"));
const utils_2 = require("./utils");
const identities_1 = require("./identities");
const messages_1 = require("./messages");
class LTO {
    constructor(networkId = 'L') {
        this.networkId = networkId;
        switch (this.networkId) {
            case 'L':
                this.nodeAddress = constants_1.DEFAULT_MAINNET_NODE;
                break;
            case 'T':
                this.nodeAddress = constants_1.DEFAULT_TESTNET_NODE;
                break;
        }
        this.relay = new messages_1.Relay(constants_1.DEFAULT_RELAY_SERVICE);
        this.accountFactories = {
            ed25519: new accounts_1.AccountFactoryED25519(this.networkId),
            secp256r1: new accounts_1.AccountFactoryECDSA(this.networkId, 'secp256r1'),
            secp256k1: new accounts_1.AccountFactoryECDSA(this.networkId, 'secp256k1'),
        };
    }
    set nodeAddress(url) {
        this._nodeAddress = url;
        this._node = new node_1.PublicNode(url);
        this.createAccountResolver();
    }
    get nodeAddress() {
        if (!this._nodeAddress)
            throw Error('Public node not configured');
        return this._nodeAddress;
    }
    set node(node) {
        this._node = node;
        this._nodeAddress = node.url;
        this.createAccountResolver();
    }
    get node() {
        if (!this._node)
            throw Error('Public node not configured');
        return this._node;
    }
    createAccountResolver() {
        this.accountResolver = new identities_1.AccountResolver(this.networkId, `${this.nodeAddress}/index/identifiers`, this.accountFactories);
    }
    static guardAccount(account, address, publicKey, privateKey) {
        if (privateKey instanceof Uint8Array)
            privateKey = Binary_1.default.from(privateKey).base58;
        if (publicKey instanceof Uint8Array)
            publicKey = Binary_1.default.from(publicKey).base58;
        if (privateKey && account.privateKey !== privateKey)
            throw Error('Private key mismatch');
        if (publicKey && account.publicKey !== publicKey)
            throw Error('Public key mismatch');
        if (address && account.address !== address)
            throw Error('Address mismatch');
        return account;
    }
    /**
     * Create an account.
     */
    account(settings = {}) {
        let account;
        const keyType = settings.keyType ?? settings.parent?.keyType ?? 'ed25519';
        const factory = this.accountFactories[keyType.toLowerCase()];
        if (!factory)
            throw Error(`Invalid key type: ${keyType}`);
        if (settings.derivationPath)
            settings.nonce = new Binary_1.default(settings.derivationPath);
        if (typeof settings.nonce === 'string') {
            if (!settings.nonce.startsWith('base64:')) {
                throw Error('Invalid nonce: must be a number, binary value, or base64 string prefixed with "base64:"');
            }
            settings.nonce = Binary_1.default.fromBase64(settings.nonce.slice(7));
        }
        if (settings.seed) {
            const seed = settings.seedPassword ? (0, utils_2.decryptSeed)(settings.seed, settings.seedPassword) : settings.seed;
            account = factory.createFromSeed(seed, settings.nonce);
        }
        else if (settings.parent || settings.derivationPath) {
            account = factory.createFromSeed(settings.parent?.seed ?? '', settings.nonce);
        }
        else if (settings.privateKey) {
            account = factory.createFromPrivateKey(settings.privateKey);
        }
        else if (settings.publicKey) {
            account = factory.createFromPublicKey(settings.publicKey);
        }
        else {
            account = factory.create();
        }
        if (settings.parent) {
            account.parent =
                settings.parent instanceof accounts_1.Account
                    ? settings.parent
                    : this.account({ keyType: settings.keyType, ...settings.parent });
        }
        return LTO.guardAccount(account, settings.address, settings.publicKey, settings.privateKey);
    }
    /**
     * Check if the address is valid for the current network.
     */
    isValidAddress(address) {
        return (0, utils_1.isValidAddress)(address, this.networkId);
    }
    /**
     * Use DID resolver to resolve an address into a public key account.
     */
    async resolveAccount(address) {
        return this.accountResolver.resolve(address);
    }
    /**
     * Transfer LTO from account to recipient.
     * Amount is number of LTO * 10^8.
     */
    transfer(sender, recipient, amount, attachment = '') {
        return new transactions_1.Transfer(recipient, amount, attachment).signWith(sender).broadcastTo(this.node);
    }
    /**
     * Transfer LTO from one account to up to 100 recipients.
     */
    massTransfer(sender, transfers, attachment = '') {
        return new transactions_1.MassTransfer(transfers, attachment).signWith(sender).broadcastTo(this.node);
    }
    /**
     * Burn LTO from account. *poof* it's gone.
     * Amount is number of LTO * 10^8.
     */
    burn(sender, amount) {
        return new transactions_1.Burn(amount).signWith(sender).broadcastTo(this.node);
    }
    anchor(sender, ...anchors) {
        if (anchors.length === 0)
            throw new Error('No anchors provided');
        return anchors[0] instanceof Uint8Array
            ? new transactions_1.Anchor(...anchors).signWith(sender).broadcastTo(this.node)
            : new transactions_1.MappedAnchor(...anchors).signWith(sender).broadcastTo(this.node);
    }
    /**
     * Register public keys on the blockchain.
     */
    register(sender, ...accounts) {
        return new transactions_1.Register(...accounts).signWith(sender).broadcastTo(this.node);
    }
    /**
     * Issue an association between accounts.
     */
    associate(sender, type, recipient, subject, expires, data) {
        return new transactions_1.Association(type, recipient, subject, expires, data ?? []).signWith(sender).broadcastTo(this.node);
    }
    /**
     * Revoke an association between accounts.
     */
    revokeAssociation(sender, type, recipient, subject) {
        return new transactions_1.RevokeAssociation(type, recipient, subject).signWith(sender).broadcastTo(this.node);
    }
    /**
     * Make a public statement on the blockchain.
     */
    makeStatement(sender, type, recipient, subject, data) {
        return new transactions_1.Statement(type, recipient, subject, data ?? []).signWith(sender).broadcastTo(this.node);
    }
    /**
     * Lease an amount to a public node for staking.
     */
    lease(sender, recipient, amount) {
        return new transactions_1.Lease(recipient, amount).signWith(sender).broadcastTo(this.node);
    }
    /**
     * Cancel a staking lease.
     */
    cancelLease(sender, leaseId) {
        return new transactions_1.CancelLease(leaseId).signWith(sender).broadcastTo(this.node);
    }
    /**
     * Sponsor an account.
     */
    sponsor(sender, recipient) {
        return new transactions_1.Sponsorship(recipient).signWith(sender).broadcastTo(this.node);
    }
    /**
     * Stop sponsoring an account.
     */
    cancelSponsorship(sender, recipient) {
        return new transactions_1.CancelSponsorship(recipient).signWith(sender).broadcastTo(this.node);
    }
    /**
     * Get the current account balance.
     */
    async getBalance(account) {
        const address = account instanceof accounts_1.Account ? account.address : account;
        return (await this.node.get(`/addresses/balance/${address}`)).balance;
    }
    /**
     * Set account data.
     */
    setData(account, data) {
        return new transactions_1.Data(data).signWith(account).broadcastTo(this.node);
    }
    /**
     * Get account data.
     */
    async getData(account) {
        const address = account instanceof accounts_1.Account ? account.address : account;
        const dataEntries = await this.node.get(`/addresses/data/${address}`);
        return transactions_1.Data.from({ type: transactions_1.Data.TYPE, data: dataEntries }).dict;
    }
}
exports.default = LTO;
//# sourceMappingURL=LTO.js.map