"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Binary_1 = __importDefault(require("../Binary"));
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const external_address_1 = require("../utils/external-address");
class Account {
    constructor(cypher, address, signKey, encryptKey, seed, nonce = 0) {
        this.cypher = cypher;
        this.address = address;
        this.signKey = signKey;
        this.encryptKey = encryptKey;
        this.seed = seed;
        this.keyType = cypher.keyType;
        this.networkId = (0, utils_1.getNetwork)(address);
        this.nonce = typeof nonce === 'number' ? nonce : new Binary_1.default(nonce);
    }
    /**
     * Get encrypted seed with a password
     */
    encryptSeed(password) {
        if (!this.seed)
            throw new Error('Account seed unknown');
        return (0, utils_1.encryptSeed)(this.seed, password, constants_1.SEED_ENCRYPTION_ROUNDS);
    }
    signMessage(message) {
        return new Binary_1.default(this.cypher.createSignature(new Binary_1.default(message)));
    }
    sign(input) {
        return typeof input === 'object' && 'signWith' in input ? input.signWith(this) : this.signMessage(input);
    }
    /**
     * Verify a signature with a message
     */
    verify(message, signature) {
        return this.cypher.verifySignature(new Binary_1.default(message), signature);
    }
    /**
     * Encrypt a message with the account's public key.
     * This message can only be decrypted with the account's private key.
     */
    encrypt(message) {
        const encrypted = this.cypher.encryptMessage(new Binary_1.default(message));
        return encrypted instanceof Binary_1.default ? encrypted : new Binary_1.default(encrypted);
    }
    /**
     * Decrypt a message with the account's private key.
     * This message can only be encrypted with the account's public key.
     */
    decrypt(message) {
        const decrypted = this.cypher.decryptMessage(message);
        return decrypted instanceof Binary_1.default ? decrypted : new Binary_1.default(decrypted);
    }
    /**
     * Base58 encoded public sign key
     */
    get publicKey() {
        return this.signKey.publicKey.base58;
    }
    /**
     * Base58 encoded private sign key
     */
    get privateKey() {
        return this.signKey.privateKey.base58;
    }
    /**
     * Get LTO DID of account
     */
    get did() {
        return 'did:lto:' + this.address;
    }
    getAddressOnNetwork(network) {
        const [namespace, reference] = network.split(':');
        if (['ethereum', 'eip155', 'solana', 'cosmos'].includes(namespace) && this.keyType !== 'secp256k1') {
            throw new Error(`Unsupported key type ${this.keyType} for network ${network}`);
        }
        if (namespace === 'lto')
            return (0, utils_1.buildAddress)(this.signKey.publicKey, reference || 'L');
        if (namespace === 'ethereum' || namespace === 'eip155')
            return (0, external_address_1.ethereumAddress)(this.signKey.publicKey, reference);
        throw new Error(`Unsupported network: ${network}`);
    }
}
exports.default = Account;
//# sourceMappingURL=Account.js.map