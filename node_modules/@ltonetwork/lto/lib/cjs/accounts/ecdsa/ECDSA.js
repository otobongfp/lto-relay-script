"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ECDSA = void 0;
const Cypher_1 = require("../Cypher");
const sha256_1 = require("@noble/hashes/sha256");
const sha512_1 = require("@noble/hashes/sha512");
const secp256k1_1 = require("@noble/curves/secp256k1");
const p256_1 = require("@noble/curves/p256");
const hmac_1 = require("@noble/hashes/hmac");
const AES = __importStar(require("crypto-js/aes.js"));
const Binary_1 = __importDefault(require("../../Binary"));
const bytes_1 = require("../../utils/bytes");
const utils_1 = require("@noble/hashes/utils");
const errors_1 = require("../../errors");
/**
 * Encrypts a message using ECIES
 * @see https://cryptobook.nakov.com/asymmetric-key-ciphers/ecies-public-key-encryption
 */
class ECDSA extends Cypher_1.Cypher {
    constructor(curve, sign) {
        super(curve);
        this.sign = sign;
        this.ec = curve === 'secp256k1' ? secp256k1_1.secp256k1 : p256_1.secp256r1;
    }
    createSignature(input) {
        if (!this.sign.privateKey)
            throw new Error('Unable to sign: no private key');
        const hash = (0, sha256_1.sha256)(input);
        const signature = this.ec.sign(hash, this.sign.privateKey);
        return signature.toCompactRawBytes();
    }
    verifySignature(input, signature) {
        const hash = (0, sha256_1.sha256)(input);
        const ecSignature = this.ec.Signature.fromCompact(signature);
        return this.ec.verify(ecSignature, hash, this.sign.publicKey);
    }
    encryptMessage(input) {
        const ephemeralPrivateKey = this.ec.utils.randomPrivateKey();
        const ephemeralPublicKey = this.ec.getPublicKey(ephemeralPrivateKey, true);
        const sharedSecret = this.ec.getSharedSecret(ephemeralPrivateKey, this.sign.publicKey);
        const hash = (0, sha512_1.sha512)(sharedSecret); // KDF
        const encryptionKey = hash.slice(0, hash.length / 2); // Kenc
        const macKey = hash.slice(hash.length / 2); // Kmac
        const ciphertextBase64 = AES.encrypt(new TextDecoder().decode(input), new TextDecoder().decode(encryptionKey)).toString();
        const ciphertext = Binary_1.default.fromBase64(ciphertextBase64);
        const tag = (0, hmac_1.hmac)(sha256_1.sha256, macKey, ciphertext);
        return Binary_1.default.concat(ephemeralPublicKey, tag, ciphertext);
    }
    decryptMessage(encryptedMessage) {
        const ephemeralPublicKey = encryptedMessage.slice(0, 33);
        const tag = encryptedMessage.slice(33, 65);
        const ciphertext = encryptedMessage.slice(65);
        const sharedSecret = this.ec.getSharedSecret(this.sign.privateKey, ephemeralPublicKey);
        const hash = (0, sha512_1.sha512)(sharedSecret); // KDF
        const encryptionKey = hash.slice(0, hash.length / 2); // Kenc
        const macKey = hash.slice(hash.length / 2); // Kmac
        if (!(0, bytes_1.compareBytes)(tag, (0, hmac_1.hmac)(sha256_1.sha256, macKey, ciphertext))) {
            throw new errors_1.DecryptError('Unable to decrypt message with given keys');
        }
        const decryptedCiphertext = AES.decrypt(Binary_1.default.from(ciphertext).base64, new TextDecoder().decode(encryptionKey));
        return (0, utils_1.hexToBytes)(decryptedCiphertext.toString());
    }
}
exports.ECDSA = ECDSA;
//# sourceMappingURL=ECDSA.js.map