"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AccountFactory_1 = __importDefault(require("../AccountFactory"));
const Account_1 = __importDefault(require("../Account"));
const utils_1 = require("../../utils");
const ecdsa_1 = require("../../utils/ecdsa");
const Binary_1 = __importDefault(require("../../Binary"));
const ECDSA_1 = require("./ECDSA");
const secp256k1_1 = require("@noble/curves/secp256k1");
const p256_1 = require("@noble/curves/p256");
const bip39_1 = require("@scure/bip39");
const bip32_1 = require("@scure/bip32");
const english_1 = require("@scure/bip39/wordlists/english");
const constants_1 = require("../../constants");
class AccountFactoryECDSA extends AccountFactory_1.default {
    constructor(networkId, curve) {
        super(networkId);
        this.curve = curve;
        this.ec = this.curve === 'secp256k1' ? secp256k1_1.secp256k1 : p256_1.secp256r1;
    }
    createFromSeed(seed, nonce) {
        seed || (seed = (0, bip39_1.generateMnemonic)(english_1.wordlist));
        nonce ?? (nonce = constants_1.DEFAULT_DERIVATION_PATH);
        if (this.curve === 'secp256r1')
            throw new Error('secp256r1 is not supported for creating an account from seed');
        if (typeof nonce === 'number')
            throw new Error(`For ${this.curve}, nonce must be a derivation path`);
        const seedBytes = typeof seed === 'string' ? new Uint8Array((0, bip39_1.mnemonicToSeedSync)(seed)) : seed;
        const hdkey = bip32_1.HDKey.fromMasterSeed(seedBytes);
        const child = hdkey.derive(typeof nonce === 'string' ? nonce : new Binary_1.default(nonce).toString());
        if (!child.privateKey) {
            throw new Error('Failed to generate private key from seed');
        }
        return this.createAccountFromPrivateKey(child.privateKey, seed, typeof nonce === 'number' ? nonce : new Binary_1.default(nonce));
    }
    createFromPublicKey(publicKey) {
        const publicKeyBinary = typeof publicKey === 'string' ? Binary_1.default.fromBase58(publicKey) : new Binary_1.default(publicKey);
        const compressed = { publicKey: undefined };
        const uncompressed = { publicKey: undefined };
        if (publicKeyBinary.length === 33) {
            compressed.publicKey = publicKeyBinary;
            uncompressed.publicKey = new Binary_1.default((0, ecdsa_1.decompressPublicKey)(publicKeyBinary, this.ec.CURVE));
        }
        else {
            compressed.publicKey = new Binary_1.default((0, ecdsa_1.compressPublicKey)(publicKeyBinary));
            uncompressed.publicKey = publicKeyBinary;
        }
        const address = (0, utils_1.buildAddress)(compressed.publicKey, this.networkId);
        const cypher = new ECDSA_1.ECDSA(this.curve, uncompressed);
        return new Account_1.default(cypher, address, compressed, compressed);
    }
    createFromPrivateKey(privateKey) {
        return this.createAccountFromPrivateKey(privateKey);
    }
    createAccountFromPrivateKey(privateKey, seed, nonce) {
        const privateKeyBinary = typeof privateKey === 'string' ? Binary_1.default.fromBase58(privateKey) : new Binary_1.default(privateKey);
        const compressed = {
            privateKey: privateKeyBinary,
            publicKey: new Binary_1.default(this.ec.getPublicKey(privateKeyBinary, true)),
        };
        const uncompressed = {
            privateKey: privateKeyBinary,
            publicKey: new Binary_1.default(this.ec.getPublicKey(privateKeyBinary)),
        };
        const cypher = new ECDSA_1.ECDSA(this.curve, uncompressed);
        const address = (0, utils_1.buildAddress)(compressed.publicKey, this.networkId);
        return new Account_1.default(cypher, address, compressed, compressed, seed, nonce);
    }
    createRandomPrivateKey() {
        const privateKey = secp256k1_1.secp256k1.utils.randomPrivateKey();
        return this.createFromPrivateKey(privateKey);
    }
    createRandomSeed() {
        const seed = (0, bip39_1.generateMnemonic)(english_1.wordlist);
        return this.createFromSeed(seed);
    }
    create() {
        return this.curve === 'secp256r1' ? this.createRandomPrivateKey() : this.createRandomSeed();
    }
}
exports.default = AccountFactoryECDSA;
//# sourceMappingURL=AccountFactoryECDSA.js.map