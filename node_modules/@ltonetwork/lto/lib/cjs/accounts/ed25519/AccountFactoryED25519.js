"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AccountFactory_1 = __importDefault(require("../AccountFactory"));
const Account_1 = __importDefault(require("../Account"));
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const base_1 = require("@scure/base");
const ED25519_1 = require("./ED25519");
const ed2curve_1 = __importDefault(require("ed2curve"));
const Binary_1 = __importDefault(require("../../Binary"));
const utils_1 = require("@noble/hashes/utils");
const mnemonic_1 = require("../../utils/mnemonic");
const crypto_1 = require("../../utils/crypto");
const sha256_1 = require("@noble/hashes/sha256");
class AccountFactoryED25519 extends AccountFactory_1.default {
    constructor(networkId) {
        super(networkId);
        this.keyType = 'ed25519';
    }
    createFromSeed(seed, nonce = 0) {
        const keys = AccountFactoryED25519.buildSignKeyPairFromSeed(seed, nonce);
        const sign = {
            privateKey: keys.privateKey,
            publicKey: keys.publicKey,
        };
        const encrypt = {
            privateKey: new Binary_1.default(ed2curve_1.default.convertSecretKey(keys.privateKey)),
            publicKey: new Binary_1.default(ed2curve_1.default.convertPublicKey(keys.publicKey)),
        };
        const cypher = new ED25519_1.ED25519(sign, encrypt);
        const address = (0, crypto_1.buildAddress)(sign.publicKey, this.networkId);
        return new Account_1.default(cypher, address, sign, encrypt, seed, nonce);
    }
    createFromPrivateKey(privateKey) {
        const keys = AccountFactoryED25519.buildSignKeyPairFromPrivateKey(privateKey);
        const sign = {
            privateKey: keys.privateKey,
            publicKey: keys.publicKey,
        };
        const encrypt = {
            privateKey: new Binary_1.default(ed2curve_1.default.convertSecretKey(keys.privateKey)),
            publicKey: new Binary_1.default(ed2curve_1.default.convertPublicKey(keys.publicKey)),
        };
        const cypher = new ED25519_1.ED25519(sign, encrypt);
        const address = (0, crypto_1.buildAddress)(sign.publicKey, this.networkId);
        return new Account_1.default(cypher, address, sign, encrypt);
    }
    createFromPublicKey(publicKey) {
        const publicKeyBinary = typeof publicKey === 'string' ? Binary_1.default.fromBase58(publicKey) : new Binary_1.default(publicKey);
        const sign = {
            publicKey: publicKeyBinary,
        };
        const encrypt = {
            publicKey: new Binary_1.default(ed2curve_1.default.convertPublicKey(publicKeyBinary)),
        };
        const cypher = new ED25519_1.ED25519(sign, encrypt);
        const address = (0, crypto_1.buildAddress)(sign.publicKey, this.networkId);
        return new Account_1.default(cypher, address, sign, encrypt);
    }
    create(numberOfWords = 15) {
        return this.createFromSeed((0, mnemonic_1.generateNewSeed)(numberOfWords));
    }
    static buildSignKeyPairFromSeed(seed, nonce) {
        if (!seed || typeof seed !== 'string')
            throw new Error('Missing or invalid seed phrase');
        const seedBytes = new Binary_1.default(seed);
        const seedHash = AccountFactoryED25519.buildSeedHash(seedBytes, AccountFactory_1.default.nonce(nonce));
        const keys = tweetnacl_1.default.sign.keyPair.fromSeed(seedHash);
        return {
            privateKey: new Binary_1.default(keys.secretKey),
            publicKey: new Binary_1.default(keys.publicKey),
        };
    }
    static buildSeedHash(seedBytes, nonceBytes = new Uint8Array()) {
        const seedBytesWithNonce = (0, utils_1.concatBytes)(nonceBytes, seedBytes);
        const seedHash = (0, crypto_1.secureHash)(seedBytesWithNonce);
        return (0, sha256_1.sha256)(seedHash);
    }
    static buildSignKeyPairFromPrivateKey(privateKey) {
        const privateKeyBytes = typeof privateKey === 'string' ? base_1.base58.decode(privateKey) : privateKey;
        const keys = tweetnacl_1.default.sign.keyPair.fromSecretKey(privateKeyBytes);
        return {
            privateKey: new Binary_1.default(keys.secretKey),
            publicKey: new Binary_1.default(keys.publicKey),
        };
    }
}
exports.default = AccountFactoryED25519;
//# sourceMappingURL=AccountFactoryED25519.js.map