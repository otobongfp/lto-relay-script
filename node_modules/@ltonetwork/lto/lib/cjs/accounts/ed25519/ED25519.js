"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ED25519 = void 0;
const Cypher_1 = require("../Cypher");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const blake2b_1 = require("@noble/hashes/blake2b");
const errors_1 = require("../../errors");
class ED25519 extends Cypher_1.Cypher {
    constructor(sign, encrypt) {
        super('ed25519');
        this.sign = sign;
        this.encrypt = encrypt;
    }
    static sealNonce(epk, publicKey) {
        return blake2b_1.blake2b.create({ dkLen: tweetnacl_1.default.box.nonceLength }).update(epk).update(publicKey).digest();
    }
    static seal(message, publicKey) {
        const ekp = tweetnacl_1.default.box.keyPair();
        const out = new Uint8Array(message.length + tweetnacl_1.default.box.overheadLength + tweetnacl_1.default.box.publicKeyLength);
        out.set(ekp.publicKey, 0);
        const nonce = this.sealNonce(ekp.publicKey, publicKey);
        const ct = tweetnacl_1.default.box(message, nonce, publicKey, ekp.secretKey);
        out.set(ct, tweetnacl_1.default.box.publicKeyLength);
        return out;
    }
    static sealOpen(ciphertext, publicKey, secretKey) {
        const epk = ciphertext.slice(0, tweetnacl_1.default.box.publicKeyLength);
        ciphertext = ciphertext.slice(tweetnacl_1.default.box.publicKeyLength);
        const nonce = this.sealNonce(epk, publicKey);
        return tweetnacl_1.default.box.open(ciphertext, nonce, epk, secretKey);
    }
    encryptMessage(input) {
        return ED25519.seal(input, this.encrypt.publicKey);
    }
    decryptMessage(input) {
        if (!this.encrypt.privateKey)
            throw new Error('Missing private key for decryption');
        const output = ED25519.sealOpen(input, this.encrypt.publicKey, this.encrypt.privateKey);
        if (!output)
            throw new errors_1.DecryptError('Unable to decrypt message with given keys');
        return output;
    }
    createSignature(input) {
        if (!this.sign.privateKey)
            throw new Error('Missing private key for signing');
        return tweetnacl_1.default.sign.detached(input, this.sign.privateKey);
    }
    verifySignature(input, signature) {
        return signature.length === 64 && tweetnacl_1.default.sign.detached.verify(input, signature, this.sign.publicKey);
    }
}
exports.ED25519 = ED25519;
//# sourceMappingURL=ED25519.js.map