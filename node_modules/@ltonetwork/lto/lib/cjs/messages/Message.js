"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Binary_1 = __importDefault(require("../Binary"));
const accounts_1 = require("../accounts");
const utils_1 = require("@noble/hashes/utils");
const crypto_1 = require("../utils/crypto");
const base_1 = require("@scure/base");
const convert_1 = require("../utils/convert");
const constants_1 = require("../constants");
class Message {
    constructor(data, mediaType, type = constants_1.DEFAULT_MESSAGE_TYPE) {
        this.type = type;
        if (typeof data === 'string') {
            this.mediaType = mediaType ?? 'text/plain';
            this.data = new Binary_1.default(data);
        }
        else if (data instanceof Uint8Array) {
            this.mediaType = mediaType ?? 'application/octet-stream';
            this.data = data instanceof Binary_1.default ? data : new Binary_1.default(data);
        }
        else {
            if (mediaType && mediaType !== 'application/json')
                throw new Error(`Unable to encode data as ${mediaType}`);
            this.mediaType = mediaType ?? 'application/json';
            this.data = new Binary_1.default(JSON.stringify(data));
        }
    }
    get hash() {
        return this._hash ?? new Binary_1.default(this.toBinary(false)).hash();
    }
    get encryptedData() {
        if (!this._encryptedData)
            throw new Error('Message is not encrypted');
        return this._encryptedData;
    }
    to(recipient) {
        if (this.signature)
            throw new Error('Message is already signed');
        this.recipient = typeof recipient === 'string' ? recipient : recipient.address;
        return this;
    }
    encryptFor(recipient) {
        if (this.signature)
            throw new Error('Message is already signed');
        this.recipient = recipient.address;
        this._encryptedData = recipient.encrypt((0, utils_1.concatBytes)((0, convert_1.stringToByteArrayWithSize)(this.mediaType), this.data));
        return this;
    }
    decryptWith(account) {
        if (!this._encryptedData)
            throw new Error('Message is not encrypted');
        const content = account.decrypt(this._encryptedData);
        const mediaTypeLength = (content[0] << 8) | content[1];
        this.mediaType = content.slice(2, mediaTypeLength + 2).toString();
        this.data = content.slice(mediaTypeLength + 2);
        return this;
    }
    isEncrypted() {
        return !!this._encryptedData;
    }
    signWith(sender) {
        this.timestamp ?? (this.timestamp = new Date());
        this.sender = { keyType: sender.keyType, publicKey: sender.signKey.publicKey };
        this.signature = sender.sign(this.toBinary(false));
        this._hash = this.hash;
        return this;
    }
    isSigned() {
        return !!this.signature;
    }
    verifySignature() {
        if (!this.signature || !this.sender)
            throw new Error('Message is not signed');
        return (0, accounts_1.cypher)(this.sender).verifySignature(this.toBinary(false), this.signature);
    }
    verifyHash() {
        return this._hash === undefined || this._hash.hex === new Binary_1.default(this.toBinary(false)).hash().hex;
    }
    toBinary(withSignature = true) {
        if (!this.recipient)
            throw new Error('Recipient not set');
        if (!this.sender || !this.timestamp || (withSignature && !this.signature))
            throw new Error('Message not signed');
        const data = this._encryptedData
            ? (0, convert_1.bytesToByteArrayWithSize)(this._encryptedData, 'int32')
            : (0, utils_1.concatBytes)((0, convert_1.stringToByteArrayWithSize)(this.mediaType), (0, convert_1.bytesToByteArrayWithSize)(this.data, 'int32'));
        return (0, utils_1.concatBytes)((0, convert_1.stringToByteArrayWithSize)(this.type), Uint8Array.from([(0, crypto_1.keyTypeId)(this.sender.keyType)]), this.sender.publicKey, base_1.base58.decode(this.recipient), (0, convert_1.longToByteArray)(this.timestamp.getTime()), Uint8Array.from([this._encryptedData ? 1 : 0]), data, withSignature ? this.signature : new Uint8Array(0));
    }
    toJSON() {
        const base = {
            type: this.type,
            sender: this.sender ? { keyType: this.sender.keyType, publicKey: this.sender.publicKey.base58 } : undefined,
            recipient: this.recipient,
            timestamp: this.timestamp,
            signature: this.signature?.base58,
            hash: this.hash.base58,
        };
        return this._encryptedData
            ? { ...base, encryptedData: 'base64:' + this._encryptedData?.base64 }
            : { ...base, mediaType: this.mediaType, data: 'base64:' + this.data?.base64 };
    }
    static from(data) {
        return data instanceof Uint8Array ? this.fromBinary(data) : this.fromJSON(data);
    }
    static fromJSON(json) {
        const message = Object.create(Message.prototype);
        message.type = json.type;
        message.sender = {
            keyType: json.sender.keyType,
            publicKey: Binary_1.default.fromBase58(json.sender.publicKey),
        };
        message.recipient = json.recipient;
        message.timestamp = json.timestamp instanceof Date ? json.timestamp : new Date(json.timestamp);
        if (json.signature)
            message.signature = Binary_1.default.fromBase58(json.signature);
        if (json.hash)
            message._hash = Binary_1.default.fromBase58(json.hash);
        if ('encryptedData' in json) {
            message._encryptedData =
                typeof json.encryptedData === 'string' && json.encryptedData.startsWith('base64:')
                    ? Binary_1.default.fromBase64(json.encryptedData.slice(7))
                    : new Binary_1.default(json.encryptedData);
        }
        else {
            message.mediaType = json.mediaType;
            message.data =
                typeof json.data === 'string' && json.data.startsWith('base64:')
                    ? Binary_1.default.fromBase64(json.data.slice(7))
                    : new Binary_1.default(json.data);
        }
        return message;
    }
    static fromBinary(data) {
        const message = Object.create(Message.prototype);
        let offset = 0;
        const typeBytes = (0, convert_1.byteArrayWithSizeToBytes)(data.slice(offset));
        message.type = new Binary_1.default(typeBytes).toString();
        offset += typeBytes.length + 2;
        const senderKeyType = data[offset++];
        const senderPublicKeyLength = senderKeyType === 1 ? 32 : 33;
        const senderPublicKey = data.slice(offset, offset + senderPublicKeyLength);
        message.sender = { keyType: (0, crypto_1.keyTypeFromId)(senderKeyType), publicKey: new Binary_1.default(senderPublicKey) };
        offset += senderPublicKeyLength;
        message.recipient = base_1.base58.encode(data.slice(offset, offset + 26));
        offset += 26;
        message.timestamp = new Date((0, convert_1.byteArrayToLong)(data.slice(offset, offset + 8)));
        offset += 8;
        const encrypted = data[offset++] === 1;
        if (encrypted) {
            message._encryptedData = new Binary_1.default((0, convert_1.byteArrayWithSizeToBytes)(data.slice(offset), 'int32'));
            offset += message._encryptedData.length + 4;
        }
        else {
            const mediaTypeBytes = (0, convert_1.byteArrayWithSizeToBytes)(data.slice(offset));
            message.mediaType = new Binary_1.default(mediaTypeBytes).toString();
            offset += mediaTypeBytes.length + 2;
            message.data = new Binary_1.default((0, convert_1.byteArrayWithSizeToBytes)(data.slice(offset), 'int32'));
            offset += message.data.length + 4;
        }
        const signature = data.slice(offset);
        if (signature.length > 0)
            message.signature = new Binary_1.default(signature);
        return message;
    }
}
exports.default = Message;
//# sourceMappingURL=Message.js.map