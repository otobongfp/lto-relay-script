"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const sha256_1 = require("@noble/hashes/sha256");
const hmac_1 = require("@noble/hashes/hmac");
const bytes_1 = require("./utils/bytes");
const utils_1 = require("@noble/hashes/utils");
const base_1 = require("@scure/base");
const base64 = __importStar(require("./utils/base64"));
class Binary extends Uint8Array {
    constructor(value) {
        if (typeof value === 'number') {
            super(value);
        }
        else {
            const bytes = typeof value === 'string' ? new TextEncoder().encode(value) : value || [];
            super(bytes);
        }
    }
    get base58() {
        return base_1.base58.encode(this);
    }
    get base64() {
        return base64.encode(this);
    }
    get hex() {
        return (0, utils_1.bytesToHex)(this);
    }
    get dataView() {
        return new DataView(this.buffer);
    }
    /** Create a SHA256 hash */
    hash() {
        return new Binary((0, sha256_1.sha256)(new Uint8Array(this)));
    }
    /** Create HMAC SHA256 hash */
    hmac(key) {
        return new Binary((0, hmac_1.hmac)(sha256_1.sha256, key, this));
    }
    toString() {
        return new TextDecoder().decode(this);
    }
    slice(start, end) {
        return new Binary(super.slice(start, end));
    }
    reverse() {
        super.reverse();
        return this;
    }
    toReversed() {
        return new Binary(this).reverse();
    }
    static from(arrayLike, mapfn, thisArg) {
        return new Binary(typeof arrayLike === 'string' ? arrayLike : super.from(arrayLike, mapfn, thisArg));
    }
    static fromBase58(value) {
        return new Binary(base_1.base58.decode(value));
    }
    static fromBase64(value) {
        return new Binary(base64.decode(value));
    }
    static fromHex(value) {
        return new Binary((0, utils_1.hexToBytes)(value));
    }
    static fromMultibase(value) {
        const code = value.charAt(0);
        const encoded = value.slice(1);
        switch (code) {
            case 'z':
                return Binary.fromBase58(encoded);
            case 'm':
                return Binary.fromBase64(encoded);
            case 'f':
            case 'F':
                return Binary.fromHex(encoded);
            default:
                throw new Error(`Unsupported multi-base encoding: ${code}`);
        }
    }
    // Big Endian
    static fromInt16(value) {
        return new Binary((0, bytes_1.int16ToBytes)(value));
    }
    // Big Endian
    static fromInt32(value) {
        return new Binary((0, bytes_1.int32ToBytes)(value));
    }
    static concat(...items) {
        const length = items.reduce((sum, item) => sum + item.length, 0);
        const merged = new Binary(length);
        let pos = 0;
        for (const item of items) {
            merged.set(item, pos);
            pos += item.length;
        }
        return merged;
    }
}
exports.default = Binary;
//# sourceMappingURL=Binary.js.map