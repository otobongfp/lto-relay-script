"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringToByteArrayWithSize = exports.stringToByteArray = exports.byteArrayToLong = exports.longToByteArray = exports.byteArrayWithSizeToBytes = exports.bytesToByteArrayWithSize = exports.integerToByteArray = exports.shortToByteArray = exports.booleanToBytes = void 0;
const bytes_1 = require("./bytes");
function booleanToBytes(input) {
    if (typeof input !== 'boolean')
        throw new Error('Boolean input is expected');
    return Uint8Array.from(input ? [1] : [0]);
}
exports.booleanToBytes = booleanToBytes;
function shortToByteArray(input) {
    if (typeof input !== 'number')
        throw new Error('Numeric input is expected');
    return (0, bytes_1.int16ToBytes)(input);
}
exports.shortToByteArray = shortToByteArray;
function integerToByteArray(input) {
    if (typeof input !== 'number')
        throw new Error('Numeric input is expected');
    return (0, bytes_1.int32ToBytes)(input);
}
exports.integerToByteArray = integerToByteArray;
function bytesToByteArrayWithSize(input, lengthField = 'int16') {
    if (!(input instanceof Array || input instanceof Uint8Array))
        throw new Error('Byte array or Uint8Array input is expected');
    else if (input instanceof Array && !input.every((n) => typeof n === 'number'))
        throw new Error('Byte array contains non-numeric elements');
    if (!(input instanceof Array))
        input = Array.prototype.slice.call(input);
    if (input.length > (lengthField == 'int16' ? 65535 : 4294967295)) {
        throw new Error(`Input is too long for ${lengthField} length field`);
    }
    const lengthBytes = lengthField == 'int16' ? (0, bytes_1.int16ToBytes)(input.length) : (0, bytes_1.int32ToBytes)(input.length);
    return Uint8Array.from([...lengthBytes, ...input]);
}
exports.bytesToByteArrayWithSize = bytesToByteArrayWithSize;
function byteArrayWithSizeToBytes(input, lengthField = 'int16') {
    if (!(input instanceof Uint8Array))
        throw new Error('Uint8Array input is expected');
    const lengthFieldBytes = lengthField == 'int16' ? 2 : 4;
    const lengthBytes = input.slice(0, lengthFieldBytes);
    const length = (0, bytes_1.bytesToInt)(lengthBytes);
    return input.slice(lengthFieldBytes, length + lengthFieldBytes);
}
exports.byteArrayWithSizeToBytes = byteArrayWithSizeToBytes;
function longToByteArray(input) {
    if (typeof input !== 'number')
        throw new Error('Numeric input is expected');
    const bytes = new Array(7);
    for (let k = 7; k >= 0; k--) {
        bytes[k] = input & 255;
        input = input / 256;
    }
    return Uint8Array.from(bytes);
}
exports.longToByteArray = longToByteArray;
function byteArrayToLong(input) {
    if (!(input instanceof Uint8Array))
        throw new Error('Uint8Array input is expected');
    let result = 0;
    for (let i = 0; i < input.length; i++) {
        result = result * 256 + input[i];
    }
    return result;
}
exports.byteArrayToLong = byteArrayToLong;
function stringToByteArray(input) {
    if (typeof input !== 'string')
        throw new Error('String input is expected');
    return new TextEncoder().encode(input);
}
exports.stringToByteArray = stringToByteArray;
function stringToByteArrayWithSize(input, lengthField = 'int16') {
    if (typeof input !== 'string')
        throw new Error('String input is expected');
    const stringBytes = new TextEncoder().encode(input);
    if (stringBytes.length > (lengthField == 'int16' ? 65535 : 4294967295)) {
        throw new Error(`Input is too long for ${lengthField} length field`);
    }
    const lengthBytes = lengthField == 'int16' ? (0, bytes_1.int16ToBytes)(stringBytes.length) : (0, bytes_1.int32ToBytes)(stringBytes.length);
    return Uint8Array.from([...lengthBytes, ...stringBytes]);
}
exports.stringToByteArrayWithSize = stringToByteArrayWithSize;
//# sourceMappingURL=convert.js.map