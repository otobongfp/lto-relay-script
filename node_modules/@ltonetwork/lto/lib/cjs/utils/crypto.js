"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.keyTypeFromId = exports.keyTypeId = exports.getNetwork = exports.buildAddress = exports.isValidAddress = exports.secureHash = void 0;
const base_1 = require("@scure/base");
const bytes_1 = require("./bytes");
const utils_1 = require("@noble/hashes/utils");
const constants = __importStar(require("../constants"));
const sha256_1 = require("@noble/hashes/sha256");
const blake2b_1 = require("@noble/hashes/blake2b");
const ADDRESS_VERSION = 1;
function secureHash(input) {
    return (0, sha256_1.sha256)((0, blake2b_1.blake2b)(input, { dkLen: 32 }));
}
exports.secureHash = secureHash;
function isValidAddress(address, networkId) {
    if (!address || typeof address !== 'string')
        throw new Error('Missing or invalid address');
    const networkByte = typeof networkId === 'string' ? networkId.charCodeAt(0) : networkId;
    const addressBytes = base_1.base58.decode(address);
    if (addressBytes[0] !== ADDRESS_VERSION)
        return false;
    if (networkByte !== undefined && addressBytes[1] !== networkByte)
        return false;
    const key = addressBytes.slice(0, 22);
    const check = addressBytes.slice(22, 26);
    const keyHash = secureHash(key).slice(0, 4);
    return (0, bytes_1.compareBytes)(keyHash, check);
}
exports.isValidAddress = isValidAddress;
function buildAddress(publicKeyBytes, networkId) {
    if (!publicKeyBytes ||
        (publicKeyBytes.length !== constants.PUBLIC_KEY_LENGTH &&
            publicKeyBytes.length !== constants.PUBLIC_KEY_LENGTH_ECDSA &&
            publicKeyBytes.length !== constants.UNCOMPRESSED_PUBLIC_KEY_LENGTH_ECDSA) ||
        !(publicKeyBytes instanceof Uint8Array)) {
        throw new Error('Missing or invalid public key');
    }
    const prefix = Uint8Array.from([constants.ADDRESS_VERSION, networkId.charCodeAt(0)]);
    const publicKeyHashPart = secureHash(publicKeyBytes).slice(0, 20);
    const rawAddress = (0, utils_1.concatBytes)(prefix, publicKeyHashPart);
    const addressHash = secureHash(rawAddress).slice(0, 4);
    return base_1.base58.encode((0, utils_1.concatBytes)(rawAddress, addressHash));
}
exports.buildAddress = buildAddress;
function getNetwork(address) {
    const decodedAddress = base_1.base58.decode(address);
    return String.fromCharCode(decodedAddress[1]);
}
exports.getNetwork = getNetwork;
function keyTypeId(keyType) {
    const types = {
        ed25519: 1,
        secp256k1: 2,
        secp256r1: 3,
    };
    if (!(keyType in types))
        throw Error('Key type not supported');
    return types[keyType];
}
exports.keyTypeId = keyTypeId;
function keyTypeFromId(keyTypeId) {
    const types = {
        1: 'ed25519',
        2: 'secp256k1',
        3: 'secp256r1',
    };
    if (!(keyTypeId in types))
        throw Error('Key type not supported');
    return types[keyTypeId];
}
exports.keyTypeFromId = keyTypeFromId;
//# sourceMappingURL=crypto.js.map