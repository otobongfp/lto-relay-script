"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytesToInt = exports.int16ToBytes = exports.int32ToBytes = exports.generateRandomUint32Array = exports.compareBytes = void 0;
const sha256_1 = require("@noble/hashes/sha256");
const utils_1 = require("@noble/hashes/utils");
function compareBytes(array1, array2) {
    return array1.length === array2.length && array1.every((c, i) => c === array2[i]);
}
exports.compareBytes = compareBytes;
function generateRandomUint32Array(length) {
    if (!length || length < 0)
        throw new Error('Missing or invalid array length');
    const a = (0, utils_1.randomBytes)(length);
    const b = (0, utils_1.randomBytes)(length);
    const result = new Uint32Array(length);
    for (let i = 0; i < length; i++) {
        const hash = (0, utils_1.bytesToHex)((0, sha256_1.sha256)(`${a[i]}${b[i]}`));
        const randomValue = parseInt(hash.slice(0, 13), 16);
        result.set([randomValue], i);
    }
    return result;
}
exports.generateRandomUint32Array = generateRandomUint32Array;
// Uses big endian
function int32ToBytes(value) {
    const bytes = new Uint8Array(4);
    bytes[3] = value & 0xff;
    bytes[2] = (value >> 8) & 0xff;
    bytes[1] = (value >> 16) & 0xff;
    bytes[0] = (value >> 24) & 0xff;
    return bytes;
}
exports.int32ToBytes = int32ToBytes;
// Uses big endian
function int16ToBytes(value) {
    const bytes = new Uint8Array(2);
    bytes[1] = value & 0xff;
    bytes[0] = (value >> 8) & 0xff;
    return bytes;
}
exports.int16ToBytes = int16ToBytes;
function bytesToInt(bytes) {
    let value = 0;
    for (let i = 0; i < bytes.length; i++) {
        value += bytes[i] << (8 * (bytes.length - i - 1));
    }
    return value;
}
exports.bytesToInt = bytesToInt;
//# sourceMappingURL=bytes.js.map