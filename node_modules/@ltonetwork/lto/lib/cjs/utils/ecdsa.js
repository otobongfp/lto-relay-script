"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decompressPublicKey = exports.compressPublicKey = void 0;
const secp256k1_1 = require("@noble/curves/secp256k1");
const utils_1 = require("@noble/curves/abstract/utils");
function compressPublicKey(pubKey) {
    if (pubKey[0] !== 0x04) {
        throw new Error('Invalid uncompressed public key');
    }
    const x = pubKey.slice(1, 33);
    const y = pubKey.slice(33);
    const isYOdd = (y[y.length - 1] & 1) === 1;
    const prefix = isYOdd ? 0x03 : 0x02;
    return Uint8Array.from([prefix, ...x]);
}
exports.compressPublicKey = compressPublicKey;
function decompressPublicKey(compressedPublicKey, curve = secp256k1_1.secp256k1.CURVE) {
    const len = compressedPublicKey.length;
    const head = compressedPublicKey[0];
    const tail = compressedPublicKey.slice(1);
    if (len === 33 && (head === 0x02 || head === 0x03)) {
        const x = (0, utils_1.bytesToNumberBE)(tail);
        const Fp = curve.Fp;
        const y2 = Fp.add(Fp.add(Fp.mul(Fp.mul(x, x), x), Fp.mul(curve.a, x)), curve.b);
        let y = Fp.sqrt(y2);
        const isYOdd = (y & 1n) === 1n;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
            y = Fp.neg(y);
        const xBytes = Fp.toBytes(x);
        const yBytes = Fp.toBytes(y);
        return Uint8Array.from([0x04, ...xBytes, ...yBytes]);
    }
    else {
        throw new Error('Invalid compressed public key');
    }
}
exports.decompressPublicKey = decompressPublicKey;
//# sourceMappingURL=ecdsa.js.map