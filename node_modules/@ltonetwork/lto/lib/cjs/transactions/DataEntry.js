"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dictToData = void 0;
const convert_1 = require("../utils/convert");
const utils_1 = require("@noble/hashes/utils");
const Binary_1 = __importDefault(require("../Binary"));
class DataEntry {
    constructor(key, type, value) {
        this.key = key;
        this.type = type;
        this.value = DataEntry.guard(key, type, value);
    }
    toBinary() {
        return (0, utils_1.concatBytes)((0, convert_1.stringToByteArrayWithSize)(this.key), this.valueToBinary());
    }
    valueToBinary() {
        switch (this.type) {
            case 'integer':
                return (0, utils_1.concatBytes)(Uint8Array.from([0]), (0, convert_1.longToByteArray)(this.value));
            case 'boolean':
                return (0, utils_1.concatBytes)(Uint8Array.from([1]), Uint8Array.from([+this.value]));
            case 'binary':
                return (0, utils_1.concatBytes)(Uint8Array.from([2]), (0, convert_1.bytesToByteArrayWithSize)(this.value));
            case 'string':
                return (0, utils_1.concatBytes)(Uint8Array.from([3]), (0, convert_1.stringToByteArrayWithSize)(this.value));
        }
    }
    toJSON() {
        return {
            key: this.key,
            type: this.type,
            value: this.value instanceof Binary_1.default ? 'base64:' + this.value.base64 : this.value,
        };
    }
    static from(data) {
        const value = data.type === 'binary' && typeof data.value === 'string' && data.value.startsWith('base64:')
            ? Binary_1.default.fromBase64(data.value.slice(7))
            : data.value;
        return new DataEntry(data.key, data.type, value);
    }
    static guess(key, value) {
        if (typeof value === 'number')
            return new DataEntry(key, 'integer', value);
        if (typeof value === 'boolean')
            return new DataEntry(key, 'boolean', value);
        if (typeof value === 'string')
            return new DataEntry(key, 'string', value);
        if (value instanceof Uint8Array)
            return new DataEntry(key, 'binary', value);
        throw Error('Type not recognized');
    }
    static guard(key, type, value) {
        switch (type) {
            case 'integer':
                if (typeof value !== 'number')
                    throw Error(`Invalid value for data entry '${key}' of type ${type}`);
                return value;
            case 'boolean':
                if (typeof value !== 'boolean')
                    throw Error(`Invalid value for data entry '${key}' of type ${type}`);
                return value;
            case 'binary':
                if (!(value instanceof Uint8Array))
                    throw Error(`Invalid value for data entry '${key}' of type ${type}`);
                return new Binary_1.default(value);
            case 'string':
                if (typeof value !== 'string')
                    throw Error(`Invalid value for data entry '${key}' of type ${type}`);
                return value;
            default:
                throw Error(`Unsupported data entry type ${type}`);
        }
    }
}
exports.default = DataEntry;
function dictToData(dictionary) {
    const data = [];
    for (const key in dictionary) {
        data.push(DataEntry.guess(key, dictionary[key]));
    }
    return data;
}
exports.dictToData = dictToData;
//# sourceMappingURL=DataEntry.js.map