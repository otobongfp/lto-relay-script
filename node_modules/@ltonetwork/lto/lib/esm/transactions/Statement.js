import Transaction from './Transaction.js';
import { concatBytes } from '@noble/hashes/utils';
import { base58 } from '@scure/base';
import * as convert from '../utils/convert.js';
import { keyTypeId } from '../utils/crypto.js';
import Binary from '../Binary.js';
import { default as DataEntry, dictToData } from './DataEntry.js';
const BASE_FEE = 50000000;
const VAR_FEE = 10000000;
const VAR_BYTES = 256;
const DEFAULT_VERSION = 3;
class Statement extends Transaction {
    constructor(statementType, recipient, subject, data = []) {
        super(Statement.TYPE, DEFAULT_VERSION);
        this.data = [];
        this.statementType = statementType;
        if (recipient)
            this.recipient = typeof recipient === 'string' ? recipient : recipient.address;
        if (subject)
            this.subject = new Binary(subject);
        this.data = Array.isArray(data) ? data : dictToData(data);
        this.fee = BASE_FEE + Math.ceil(this.dataToBinary().length / VAR_BYTES) * VAR_FEE;
    }
    dataToBinary() {
        return this.data.reduce((binary, entry) => concatBytes(binary, entry.toBinary()), new Uint8Array());
    }
    toBinaryV3() {
        return concatBytes(Uint8Array.from([this.type, this.version]), convert.stringToByteArray(this.networkId), convert.longToByteArray(this.timestamp), Uint8Array.from([keyTypeId(this.senderKeyType)]), base58.decode(this.senderPublicKey), convert.longToByteArray(this.fee), convert.longToByteArray(this.statementType), Uint8Array.from([this.recipient ? 1 : 0]), this.recipient ? base58.decode(this.recipient) : new Uint8Array(), convert.shortToByteArray(this.subject?.length ?? 0), this.subject ?? new Uint8Array(), convert.shortToByteArray(this.data.length), this.dataToBinary());
    }
    toBinary() {
        if (!this.sender)
            throw Error('Transaction sender not set');
        switch (this.version) {
            case 3:
                return this.toBinaryV3();
            default:
                throw Error('Incorrect version');
        }
    }
    toJSON() {
        return {
            id: this.id,
            type: this.type,
            version: this.version,
            sender: this.sender,
            senderKeyType: this.senderKeyType,
            senderPublicKey: this.senderPublicKey,
            sponsor: this.sponsor,
            sponsorKeyType: this.sponsorKeyType,
            sponsorPublicKey: this.sponsorPublicKey,
            fee: this.fee,
            timestamp: this.timestamp,
            statementType: this.statementType,
            recipient: this.recipient,
            subject: this.subject?.base58,
            data: this.data?.map((entry) => entry.toJSON()),
            proofs: this.proofs,
            height: this.height,
        };
    }
    get dict() {
        const dictionary = {};
        this.data.forEach((entry) => (dictionary[entry.key] = entry.value));
        return dictionary;
    }
    static from(data) {
        const tx = new Statement(data.associationType, data.recipient, data.subject ? Binary.fromBase58(data.subject) : undefined).initFrom(data);
        tx.data = (data.data ?? []).map(DataEntry.from);
        return tx;
    }
}
Statement.TYPE = 23;
export default Statement;
//# sourceMappingURL=Statement.js.map