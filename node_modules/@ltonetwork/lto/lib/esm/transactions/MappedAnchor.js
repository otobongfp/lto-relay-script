import Transaction from './Transaction.js';
import { concatBytes } from '@noble/hashes/utils';
import { base58 } from '@scure/base';
import * as convert from '../utils/convert.js';
import { keyTypeId } from '../utils/crypto.js';
import Binary from '../Binary.js';
const BASE_FEE = 25000000;
const VAR_FEE = 10000000;
const DEFAULT_VERSION = 3;
class MappedAnchor extends Transaction {
    constructor(...anchors) {
        super(MappedAnchor.TYPE, DEFAULT_VERSION, BASE_FEE + anchors.length * VAR_FEE);
        this.anchors = anchors.map((pair) => ({ key: new Binary(pair.key), value: new Binary(pair.value) }));
    }
    /** Get binary for anchors as used by toBinary methods */
    anchorsBinary() {
        return this.anchors.reduce((current, pair) => concatBytes(current, convert.shortToByteArray(pair.key.length), pair.key, convert.shortToByteArray(pair.value.length), pair.value), new Uint8Array());
    }
    toBinaryV3() {
        return concatBytes(Uint8Array.from([this.type, this.version]), convert.stringToByteArray(this.networkId), convert.longToByteArray(this.timestamp), Uint8Array.from([keyTypeId(this.senderKeyType)]), base58.decode(this.senderPublicKey), convert.longToByteArray(this.fee), convert.shortToByteArray(this.anchors.length), this.anchorsBinary());
    }
    toBinary() {
        if (!this.sender)
            throw Error('Transaction sender not set');
        switch (this.version) {
            case 3:
                return this.toBinaryV3();
            default:
                throw Error('Incorrect version');
        }
    }
    toJSON() {
        const anchors = {};
        this.anchors.forEach((pair) => (anchors[pair.key.base58] = pair.value.base58));
        return {
            id: this.id,
            type: this.type,
            version: this.version,
            sender: this.sender,
            senderKeyType: this.senderKeyType,
            senderPublicKey: this.senderPublicKey,
            sponsor: this.sponsor,
            sponsorKeyType: this.sponsorKeyType,
            sponsorPublicKey: this.sponsorPublicKey,
            fee: this.fee,
            timestamp: this.timestamp,
            anchors,
            proofs: this.proofs,
            height: this.height,
        };
    }
    static from(data) {
        const anchors = Object.entries(data.anchors).map(([key, value]) => ({
            key: Binary.fromBase58(key),
            value: Binary.fromBase58(value),
        }));
        return new MappedAnchor(...anchors).initFrom(data);
    }
}
MappedAnchor.TYPE = 22;
export default MappedAnchor;
//# sourceMappingURL=MappedAnchor.js.map