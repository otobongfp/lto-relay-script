import Event from './Event.js';
import Binary from '../Binary.js';
import MergeConflict from './MergeConflict.js';
import { concatBytes, randomBytes } from '@noble/hashes/utils';
import { compareBytes } from '../utils/bytes.js';
import { base58 } from '@scure/base';
import { sha256 } from '@noble/hashes/sha256';
import { buildAddress, getNetwork, secureHash } from '../utils/crypto.js';
import { stringToByteArray } from '../utils/convert.js';
export const EVENT_CHAIN_V1 = 0x41;
export const EVENT_CHAIN_V2 = 0x42;
const DERIVED_ID_VERSION = 0x51;
export default class EventChain {
    constructor(idOrAccount, nonce) {
        this.events = [];
        if (typeof idOrAccount === 'string') {
            this.id = idOrAccount;
            this.networkId = getNetwork(this.id);
        }
        else {
            const account = idOrAccount;
            const nonceBytes = typeof nonce !== 'undefined' ? EventChain.createNonce(nonce) : EventChain.getRandomNonce();
            this.networkId = getNetwork(account.address);
            this.id = EventChain.buildId(EVENT_CHAIN_V2, this.networkId, Binary.fromBase58(account.publicKey), nonceBytes);
        }
    }
    get version() {
        return Binary.fromBase58(this.id)[0];
    }
    /** @deprecated */
    static create(account, nonce) {
        return new EventChain(account, nonce);
    }
    createDerivedId(nonce) {
        const nonceBytes = nonce ? EventChain.createNonce(nonce) : EventChain.getRandomNonce();
        return EventChain.buildId(DERIVED_ID_VERSION, this.networkId, Binary.fromBase58(this.id), nonceBytes);
    }
    isDerivedId(id) {
        return EventChain.validateId(DERIVED_ID_VERSION, this.networkId, id, Binary.fromBase58(this.id));
    }
    add(eventOrChain) {
        if (this.events.length > 0 && !this.latestEvent.isSigned())
            throw new Error('Unable to add event: last event on chain is not signed');
        if (eventOrChain instanceof EventChain) {
            this.addChain(eventOrChain);
        }
        else {
            this.addEvent(eventOrChain);
        }
        return this;
    }
    addEvent(event) {
        if (!event.previous)
            event.previous = this.latestHash;
        event.version = this.version;
        this.assertEvent(event);
        this.events.push(event);
    }
    addChain(chain) {
        if (chain.id !== this.id)
            throw Error('Chain id mismatch');
        let offset = 0;
        if (chain.partial) {
            offset = this.events.findIndex((event) => event.hash.hex === chain.partial.hash.hex) + 1;
            if (offset === 0)
                throw new Error(`Events don't fit onto this chain: Event ${chain.partial.hash.base58} not found`);
        }
        for (const [index, event] of chain.events.entries()) {
            if (!this.events[offset + index]) {
                this.assertEvent(event);
                this.events.push(event);
            }
            else if (this.events[offset + index].hash.hex !== event.hash.hex) {
                throw new MergeConflict(this, this.events[offset + index], chain.events[index]);
            }
        }
    }
    has(event) {
        const hash = event instanceof Event ? event.hash : event;
        return !!this.events.find((event) => event.hash.hex === hash.hex);
    }
    get latestHash() {
        return this.events.length == 0 ? this.partial?.hash || this.initialHash : this.events.slice(-1)[0].hash;
    }
    get initialHash() {
        return Binary.fromBase58(this.id).hash();
    }
    get latestEvent() {
        return this.events[this.events.length - 1];
    }
    get state() {
        if (this.events.length > 0 && !this.events[this.events.length - 1].isSigned()) {
            throw new Error('Unable to get state: last event on chain is not signed');
        }
        return this.stateAt(this.events.length);
    }
    get initialState() {
        return Binary.fromBase58(this.id).reverse().hash();
    }
    stateAt(length) {
        if (length > this.events.length)
            throw new Error('Unable to get state: out of bounds');
        const initial = this.partial?.state ?? this.initialState;
        return this.events.slice(0, length).reduce((state, event) => Binary.concat(state, event.hash).hash(), initial);
    }
    assertEvent(event) {
        if (!event.previous || event.previous.hex != this.latestHash.hex)
            throw new Error(`Event doesn't fit onto the chain after ${this.latestHash.base58}`);
        if (!event.verifyHash())
            throw new Error(`Invalid hash of event ${event.hash.base58}`);
        if (event.isSigned() && !event.verifySignature())
            throw new Error(`Invalid signature of event ${event.hash.base58}`);
    }
    validate() {
        if (this.events.length === 0)
            throw new Error('No events on event chain');
        this.validateEvents();
        if (this.events[0].previous.hex === this.initialHash.hex)
            this.validateGenesis();
    }
    validateEvents() {
        let previous = this.partial?.hash ?? this.initialHash;
        for (const event of this.events) {
            if (!event.isSigned()) {
                let desc;
                try {
                    desc = `Event ${event.hash.base58}`;
                }
                catch (e) {
                    desc = event === this.latestEvent ? 'Last event' : `Event after ${previous.base58}`;
                }
                throw new Error(`${desc} is not signed`);
            }
            if (!event.verifyHash())
                throw new Error(`Invalid hash of event ${event.hash.base58}`);
            if (!event.verifySignature())
                throw new Error(`Invalid signature of event ${event.hash.base58}`);
            if (previous.hex !== event.previous.hex)
                throw new Error(`Event ${event.hash.base58} doesn't fit onto the chain`);
            previous = event.hash;
        }
    }
    validateGenesis() {
        const isValid = EventChain.validateId(EVENT_CHAIN_V2, this.networkId, this.id, this.events[0].signKey.publicKey) ||
            EventChain.validateId(EVENT_CHAIN_V1, this.networkId, this.id, this.events[0].signKey.publicKey);
        if (!isValid)
            throw new Error('Genesis event is not signed by chain creator');
    }
    isSigned() {
        return this.events.every((e) => e.isSigned());
    }
    startingWith(start) {
        return this.createPartial(start, 0);
    }
    startingAfter(start) {
        return this.createPartial(start, 1);
    }
    createPartial(start, offset) {
        const startHash = start instanceof Event ? start.hash : start;
        if (this.initialHash.hex === startHash.hex)
            return this;
        const foundIndex = this.events.findIndex((e) => e.hash.hex === startHash.hex);
        if (foundIndex < 0)
            throw new Error(`Event ${startHash.hex} is not part of this event chain`);
        const index = foundIndex + offset;
        if (index === 0)
            return this;
        const chain = new EventChain(this.id);
        chain.partial = {
            hash: this.events[index - 1].hash,
            state: this.stateAt(index),
        };
        chain.events = this.events.slice(index);
        return chain;
    }
    isPartial() {
        return !!this.partial;
    }
    isCreatedBy(account) {
        const networkId = getNetwork(account.address);
        const publicKey = Binary.fromBase58(account.publicKey);
        return (EventChain.validateId(EVENT_CHAIN_V2, networkId, this.id, publicKey) ||
            EventChain.validateId(EVENT_CHAIN_V1, networkId, this.id, publicKey));
    }
    get anchorMap() {
        const map = [];
        let state = this.partial?.state ?? this.initialState;
        for (const event of this.events) {
            map.push({ key: state, value: event.hash, signer: buildAddress(event.signKey.publicKey, this.networkId) });
            state = Binary.concat(state, event.hash).hash();
        }
        return map;
    }
    toJSON() {
        const events = this.events.map((event) => event.toJSON());
        if (this.partial)
            events.unshift({ hash: this.partial.hash.base58, state: this.partial.state.base58 });
        return { id: this.id, events };
    }
    static from(data) {
        const chain = new EventChain(data.id);
        const chainVersion = chain.version;
        if (data.events.length === 0)
            return chain;
        if ('state' in data.events[0]) {
            const partial = data.events.shift();
            chain.partial = {
                hash: Binary.fromBase58(partial.hash),
                state: Binary.fromBase58(partial.state),
            };
        }
        for (const eventData of (data.events ?? [])) {
            chain.events.push(Event.from(eventData, chainVersion));
        }
        return chain;
    }
    static createNonce(input) {
        return Uint8Array.from(sha256(input).slice(0, 20));
    }
    static getRandomNonce() {
        return randomBytes(20);
    }
    static buildId(prefix, network, group, randomBytes) {
        if (randomBytes.length !== 20)
            throw new Error('Random bytes should have a length of 20');
        const prefixBytes = Uint8Array.from([prefix]);
        const networkBytes = stringToByteArray(network);
        const publicKeyHashPart = secureHash(group).slice(0, 20);
        const rawId = concatBytes(prefixBytes, networkBytes, randomBytes, publicKeyHashPart);
        const addressHash = secureHash(rawId).slice(0, 4);
        return base58.encode(concatBytes(rawId, addressHash));
    }
    static validateId(prefix, network, id, group) {
        const idBytes = base58.decode(id);
        if (idBytes.length !== 46 || idBytes[0] !== prefix || String.fromCharCode(idBytes[1]) !== network)
            return false;
        const rawId = idBytes.slice(0, 42);
        const check = idBytes.slice(42);
        const addressHash = secureHash(rawId).slice(0, 4);
        let res = compareBytes(check, addressHash);
        if (res && group) {
            const keyBytes = rawId.slice(22);
            const publicKeyHashPart = Uint8Array.from(secureHash(group).slice(0, 20));
            res = compareBytes(keyBytes, publicKeyHashPart);
        }
        return res;
    }
}
//# sourceMappingURL=EventChain.js.map