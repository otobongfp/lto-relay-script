import Binary from '../Binary.js';
import { SEED_ENCRYPTION_ROUNDS } from '../constants.js';
import { encryptSeed, buildAddress, getNetwork } from '../utils/index.js';
import { ethereumAddress } from '../utils/external-address.js';
export default class Account {
    constructor(cypher, address, signKey, encryptKey, seed, nonce = 0) {
        this.cypher = cypher;
        this.address = address;
        this.signKey = signKey;
        this.encryptKey = encryptKey;
        this.seed = seed;
        this.keyType = cypher.keyType;
        this.networkId = getNetwork(address);
        this.nonce = typeof nonce === 'number' ? nonce : new Binary(nonce);
    }
    /**
     * Get encrypted seed with a password
     */
    encryptSeed(password) {
        if (!this.seed)
            throw new Error('Account seed unknown');
        return encryptSeed(this.seed, password, SEED_ENCRYPTION_ROUNDS);
    }
    signMessage(message) {
        return new Binary(this.cypher.createSignature(new Binary(message)));
    }
    sign(input) {
        return typeof input === 'object' && 'signWith' in input ? input.signWith(this) : this.signMessage(input);
    }
    /**
     * Verify a signature with a message
     */
    verify(message, signature) {
        return this.cypher.verifySignature(new Binary(message), signature);
    }
    /**
     * Encrypt a message with the account's public key.
     * This message can only be decrypted with the account's private key.
     */
    encrypt(message) {
        const encrypted = this.cypher.encryptMessage(new Binary(message));
        return encrypted instanceof Binary ? encrypted : new Binary(encrypted);
    }
    /**
     * Decrypt a message with the account's private key.
     * This message can only be encrypted with the account's public key.
     */
    decrypt(message) {
        const decrypted = this.cypher.decryptMessage(message);
        return decrypted instanceof Binary ? decrypted : new Binary(decrypted);
    }
    /**
     * Base58 encoded public sign key
     */
    get publicKey() {
        return this.signKey.publicKey.base58;
    }
    /**
     * Base58 encoded private sign key
     */
    get privateKey() {
        return this.signKey.privateKey.base58;
    }
    /**
     * Get LTO DID of account
     */
    get did() {
        return 'did:lto:' + this.address;
    }
    getAddressOnNetwork(network) {
        const [namespace, reference] = network.split(':');
        if (['ethereum', 'eip155', 'solana', 'cosmos'].includes(namespace) && this.keyType !== 'secp256k1') {
            throw new Error(`Unsupported key type ${this.keyType} for network ${network}`);
        }
        if (namespace === 'lto')
            return buildAddress(this.signKey.publicKey, reference || 'L');
        if (namespace === 'ethereum' || namespace === 'eip155')
            return ethereumAddress(this.signKey.publicKey, reference);
        throw new Error(`Unsupported network: ${network}`);
    }
}
//# sourceMappingURL=Account.js.map