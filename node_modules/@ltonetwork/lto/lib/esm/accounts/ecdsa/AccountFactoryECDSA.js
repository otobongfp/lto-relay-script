import AccountFactory from '../AccountFactory.js';
import Account from '../Account.js';
import { buildAddress } from '../../utils/index.js';
import { compressPublicKey, decompressPublicKey } from '../../utils/ecdsa.js';
import Binary from '../../Binary.js';
import { ECDSA } from './ECDSA.js';
import { secp256k1 } from '@noble/curves/secp256k1';
import { secp256r1 } from '@noble/curves/p256';
import { mnemonicToSeedSync, generateMnemonic } from '@scure/bip39';
import { HDKey } from '@scure/bip32';
import { wordlist } from '@scure/bip39/wordlists/english';
import { DEFAULT_DERIVATION_PATH } from '../../constants.js';
export default class AccountFactoryECDSA extends AccountFactory {
    constructor(networkId, curve) {
        super(networkId);
        this.curve = curve;
        this.ec = this.curve === 'secp256k1' ? secp256k1 : secp256r1;
    }
    createFromSeed(seed, nonce) {
        seed || (seed = generateMnemonic(wordlist));
        nonce ?? (nonce = DEFAULT_DERIVATION_PATH);
        if (this.curve === 'secp256r1')
            throw new Error('secp256r1 is not supported for creating an account from seed');
        if (typeof nonce === 'number')
            throw new Error(`For ${this.curve}, nonce must be a derivation path`);
        const seedBytes = typeof seed === 'string' ? new Uint8Array(mnemonicToSeedSync(seed)) : seed;
        const hdkey = HDKey.fromMasterSeed(seedBytes);
        const child = hdkey.derive(typeof nonce === 'string' ? nonce : new Binary(nonce).toString());
        if (!child.privateKey) {
            throw new Error('Failed to generate private key from seed');
        }
        return this.createAccountFromPrivateKey(child.privateKey, seed, typeof nonce === 'number' ? nonce : new Binary(nonce));
    }
    createFromPublicKey(publicKey) {
        const publicKeyBinary = typeof publicKey === 'string' ? Binary.fromBase58(publicKey) : new Binary(publicKey);
        const compressed = { publicKey: undefined };
        const uncompressed = { publicKey: undefined };
        if (publicKeyBinary.length === 33) {
            compressed.publicKey = publicKeyBinary;
            uncompressed.publicKey = new Binary(decompressPublicKey(publicKeyBinary, this.ec.CURVE));
        }
        else {
            compressed.publicKey = new Binary(compressPublicKey(publicKeyBinary));
            uncompressed.publicKey = publicKeyBinary;
        }
        const address = buildAddress(compressed.publicKey, this.networkId);
        const cypher = new ECDSA(this.curve, uncompressed);
        return new Account(cypher, address, compressed, compressed);
    }
    createFromPrivateKey(privateKey) {
        return this.createAccountFromPrivateKey(privateKey);
    }
    createAccountFromPrivateKey(privateKey, seed, nonce) {
        const privateKeyBinary = typeof privateKey === 'string' ? Binary.fromBase58(privateKey) : new Binary(privateKey);
        const compressed = {
            privateKey: privateKeyBinary,
            publicKey: new Binary(this.ec.getPublicKey(privateKeyBinary, true)),
        };
        const uncompressed = {
            privateKey: privateKeyBinary,
            publicKey: new Binary(this.ec.getPublicKey(privateKeyBinary)),
        };
        const cypher = new ECDSA(this.curve, uncompressed);
        const address = buildAddress(compressed.publicKey, this.networkId);
        return new Account(cypher, address, compressed, compressed, seed, nonce);
    }
    createRandomPrivateKey() {
        const privateKey = secp256k1.utils.randomPrivateKey();
        return this.createFromPrivateKey(privateKey);
    }
    createRandomSeed() {
        const seed = generateMnemonic(wordlist);
        return this.createFromSeed(seed);
    }
    create() {
        return this.curve === 'secp256r1' ? this.createRandomPrivateKey() : this.createRandomSeed();
    }
}
//# sourceMappingURL=AccountFactoryECDSA.js.map