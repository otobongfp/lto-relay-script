import AccountFactory from '../AccountFactory.js';
import Account from '../Account.js';
import nacl from 'tweetnacl';
import { base58 } from '@scure/base';
import { ED25519 } from './ED25519.js';
import ed2curve from 'ed2curve';
import Binary from '../../Binary.js';
import { concatBytes } from '@noble/hashes/utils';
import { generateNewSeed } from '../../utils/mnemonic.js';
import { buildAddress, secureHash } from '../../utils/crypto.js';
import { sha256 } from '@noble/hashes/sha256';
export default class AccountFactoryED25519 extends AccountFactory {
    constructor(networkId) {
        super(networkId);
        this.keyType = 'ed25519';
    }
    createFromSeed(seed, nonce = 0) {
        const keys = AccountFactoryED25519.buildSignKeyPairFromSeed(seed, nonce);
        const sign = {
            privateKey: keys.privateKey,
            publicKey: keys.publicKey,
        };
        const encrypt = {
            privateKey: new Binary(ed2curve.convertSecretKey(keys.privateKey)),
            publicKey: new Binary(ed2curve.convertPublicKey(keys.publicKey)),
        };
        const cypher = new ED25519(sign, encrypt);
        const address = buildAddress(sign.publicKey, this.networkId);
        return new Account(cypher, address, sign, encrypt, seed, nonce);
    }
    createFromPrivateKey(privateKey) {
        const keys = AccountFactoryED25519.buildSignKeyPairFromPrivateKey(privateKey);
        const sign = {
            privateKey: keys.privateKey,
            publicKey: keys.publicKey,
        };
        const encrypt = {
            privateKey: new Binary(ed2curve.convertSecretKey(keys.privateKey)),
            publicKey: new Binary(ed2curve.convertPublicKey(keys.publicKey)),
        };
        const cypher = new ED25519(sign, encrypt);
        const address = buildAddress(sign.publicKey, this.networkId);
        return new Account(cypher, address, sign, encrypt);
    }
    createFromPublicKey(publicKey) {
        const publicKeyBinary = typeof publicKey === 'string' ? Binary.fromBase58(publicKey) : new Binary(publicKey);
        const sign = {
            publicKey: publicKeyBinary,
        };
        const encrypt = {
            publicKey: new Binary(ed2curve.convertPublicKey(publicKeyBinary)),
        };
        const cypher = new ED25519(sign, encrypt);
        const address = buildAddress(sign.publicKey, this.networkId);
        return new Account(cypher, address, sign, encrypt);
    }
    create(numberOfWords = 15) {
        return this.createFromSeed(generateNewSeed(numberOfWords));
    }
    static buildSignKeyPairFromSeed(seed, nonce) {
        if (!seed || typeof seed !== 'string')
            throw new Error('Missing or invalid seed phrase');
        const seedBytes = new Binary(seed);
        const seedHash = AccountFactoryED25519.buildSeedHash(seedBytes, AccountFactory.nonce(nonce));
        const keys = nacl.sign.keyPair.fromSeed(seedHash);
        return {
            privateKey: new Binary(keys.secretKey),
            publicKey: new Binary(keys.publicKey),
        };
    }
    static buildSeedHash(seedBytes, nonceBytes = new Uint8Array()) {
        const seedBytesWithNonce = concatBytes(nonceBytes, seedBytes);
        const seedHash = secureHash(seedBytesWithNonce);
        return sha256(seedHash);
    }
    static buildSignKeyPairFromPrivateKey(privateKey) {
        const privateKeyBytes = typeof privateKey === 'string' ? base58.decode(privateKey) : privateKey;
        const keys = nacl.sign.keyPair.fromSecretKey(privateKeyBytes);
        return {
            privateKey: new Binary(keys.secretKey),
            publicKey: new Binary(keys.publicKey),
        };
    }
}
//# sourceMappingURL=AccountFactoryED25519.js.map