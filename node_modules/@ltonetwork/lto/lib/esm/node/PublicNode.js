import { txFromData } from '../transactions/index.js';
import { RequestError } from '../errors/index.js';
export default class PublicNode {
    constructor(url, apiKey = '') {
        this.url = url.replace(/\/$/, '');
        this.apiKey = apiKey;
    }
    // Can be overridden by mock for testing
    fetch(url, options) {
        return fetch(url, options);
    }
    async post(endpoint, postData, headers = {}) {
        endpoint = endpoint.replace(/^\//, '');
        if (this.apiKey)
            headers['X-API-Key'] = this.apiKey;
        headers['content-type'] = 'application/json';
        const body = typeof postData === 'string' ? postData : JSON.stringify(postData);
        const response = await this.fetch(`${this.url}/${endpoint}`, { method: 'POST', headers, body });
        if (!response.ok)
            throw new RequestError(`${this.url}/${endpoint}`, await response.json());
        return await response.json();
    }
    async get(endpoint, headers = {}) {
        endpoint = endpoint.replace(/^\//, '');
        if (this.apiKey)
            headers['X-API-Key'] = this.apiKey;
        const response = await this.fetch(`${this.url}/${endpoint}`, { method: 'GET', headers });
        if (!response.ok)
            throw new RequestError(`${this.url}/${endpoint}`, await response.json());
        return await response.json();
    }
    async broadcast(transaction) {
        const data = await this.post('/transactions/broadcast', transaction);
        return txFromData(data);
    }
    async submit(transaction) {
        const data = await this.post('/transactions/submit', transaction);
        return txFromData(data);
    }
    status() {
        return this.get('/node/status');
    }
    async version() {
        return (await this.get('/node/version')).version;
    }
}
//# sourceMappingURL=PublicNode.js.map